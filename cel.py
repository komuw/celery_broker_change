import celery


"""
run as:
    1. python cel.py
    2. celery worker -A cel:celery_v3_obj --concurrency=1 --loglevel=DEBUG
    3. celery worker -A cel:celery_v4_obj --concurrency=1 --loglevel=DEBUG
"""


# one broker for celery v3 another for celery v4
CELERY_V3_BROKER_URL = "amqp://guest:guest@localhost:7777//"
CELERY_V4_BROKER_URL = "amqp://guest:guest@localhost:8888//"

celery_v3_obj = celery.Celery(broker=CELERY_V3_BROKER_URL)
celery_v4_obj = celery.Celery(broker=CELERY_V4_BROKER_URL)


@celery_v3_obj.task(name="adder")
def adder(a, b):
    res = a + b
    print("res: ", res)
    return res


"""
This function is a patch of the `kombu.Producer._publish`[1] method that is responsible for publishing messages to RabbitMQ.
We patch this method so that we are able to switch different BROKER_URL's based on some condition at runtime.

ref:
1. https://github.com/celery/kombu/blob/fcc4c620bf017eb456b7d9e694b64e834401ff12/kombu/messaging.py#L184-L204
"""
import json
from kombu import Producer
from kombu.connection import Connection
from kombu.entity import Queue

def _my_publish_patch(
    self,
    body,
    priority,
    content_type,
    content_encoding,
    headers,
    properties,
    routing_key,
    mandatory,
    immediate,
    exchange,
    declare,
):
    print()
    print("_my_publish_patch called.")
    print("body:: ", body)
    print()
    # Most of the code in here is copied verbatim from:
    # https://github.com/celery/kombu/blob/fcc4c620bf017eb456b7d9e694b64e834401ff12/kombu/messaging.py#L184-L204
    
    # the actual patch code
    # all our patch is in a try...except
    try:
        # we check the arguments that our task was called with
        # adder.delay(a=67, b=824)
        _delay_args = json.loads(body)[1]
        if _delay_args["a"] == 45:
            # publish to celery v3 BROKER_URL
            self.channel = Connection(CELERY_V3_BROKER_URL).channel()
        else:
            # publish to celery v4 BROKER_URL
            self.channel = Connection(CELERY_V4_BROKER_URL).channel()
    except Exception as e:
        pass

    channel = self.channel
    message = channel.prepare_message(
        body, priority, content_type, content_encoding, headers, properties
    )
    if declare:
        maybe_declare = self.maybe_declare
        [maybe_declare(entity) for entity in declare]

    # handle autogenerated queue names for reply_to
    reply_to = properties.get("reply_to")
    if isinstance(reply_to, Queue):
        properties["reply_to"] = reply_to.name
    return channel.basic_publish(
        message,
        exchange=exchange,
        routing_key=routing_key,
        mandatory=mandatory,
        immediate=immediate,
    )

# patch the publish method
Producer._publish = _my_publish_patch

if __name__ == "__main__":
    # publish some tasks
    adder.delay(a=45, b=141)
    adder.delay(a=124, b=51)
    adder.delay(a=252, b=26)
    print("celery_v3_obj.conf.BROKER_URL", celery_v3_obj.conf.BROKER_URL)
    print("celery_v3_obj.conf.conf.BROKER_TRANSPORT", celery_v3_obj.conf.BROKER_TRANSPORT)
    print("!!! adder messages enqueued !!!")
